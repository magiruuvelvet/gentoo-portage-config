From eceb72c74491a2db53a1b68a857bb5a7b9549743 Mon Sep 17 00:00:00 2001
From: Wim Taymans <wtaymans@redhat.com>
Date: Mon, 10 Jul 2023 10:07:09 +0200
Subject: [PATCH] Revert "impl-node: run the remote driver node logic remotely"

This reverts commit b8fe832188168d3950d364a5a9bcc22aff31779f.

See #3316
---
 src/modules/module-client-node/client-node.c | 35 ++++-----
 src/modules/module-client-node/remote-node.c | 75 +++++++++++++++-----
 src/pipewire/extensions/client-node.h        |  2 +-
 src/pipewire/impl-node.c                     | 30 ++++++--
 4 files changed, 100 insertions(+), 42 deletions(-)

diff --git a/src/modules/module-client-node/client-node.c b/src/modules/module-client-node/client-node.c
index c2bad3e172..e3fcf1a3fd 100644
--- a/src/modules/module-client-node/client-node.c
+++ b/src/modules/module-client-node/client-node.c
@@ -1075,6 +1075,8 @@ static void node_on_data_fd_events(struct spa_source *source)
 	if (SPA_LIKELY(source->rmask & SPA_IO_IN)) {
 		uint64_t cmd;
 		struct pw_impl_node *node = impl->this.node;
+		struct pw_node_activation *a = node->rt.target.activation;
+		int status;
 
 		if (SPA_UNLIKELY(spa_system_eventfd_read(impl->data_system,
 					impl->data_source.fd, &cmd) < 0))
@@ -1083,15 +1085,9 @@ static void node_on_data_fd_events(struct spa_source *source)
 			pw_log_info("(%s-%u) client missed %"PRIu64" wakeups",
 				node->name, node->info.id, cmd - 1);
 
-		if (impl->resource && impl->resource->version < 5) {
-			struct pw_node_activation *a = node->rt.target.activation;
-			int status = a->state[0].status;
-			spa_log_trace_fp(impl->log, "%p: got ready %d", impl, status);
-			spa_node_call_ready(&impl->callbacks, status);
-		} else {
-			spa_log_trace_fp(impl->log, "%p: got complete", impl);
-			pw_context_driver_emit_complete(node->context, node);
-		}
+		status = a->state[0].status;
+		spa_log_trace_fp(impl->log, "%p: got ready %d", impl, status);
+		spa_node_call_ready(&impl->callbacks, status);
 	}
 }
 
@@ -1201,14 +1197,16 @@ static void node_peer_added(void *data, struct pw_impl_node *peer)
 	struct impl *impl = data;
 	struct pw_memblock *m;
 
+	if (peer == impl->this.node)
+		return;
+
 	m = pw_mempool_import_block(impl->client->pool, peer->activation);
 	if (m == NULL) {
-		pw_log_warn("%p: can't ensure mem: %m", impl);
+		pw_log_debug("%p: can't ensure mem: %m", impl);
 		return;
 	}
-
-	pw_log_debug("%p: peer %p/%p id:%u added mem_id:%u", impl, peer,
-			impl->this.node, peer->info.id, m->id);
+	pw_log_debug("%p: peer %p id:%u added mem_id:%u", &impl->this, peer,
+			peer->info.id, m->id);
 
 	if (impl->resource == NULL)
 		return;
@@ -1226,15 +1224,17 @@ static void node_peer_removed(void *data, struct pw_impl_node *peer)
 	struct impl *impl = data;
 	struct pw_memblock *m;
 
+	if (peer == impl->this.node)
+		return;
+
 	m = pw_mempool_find_fd(impl->client->pool, peer->activation->fd);
 	if (m == NULL) {
 		pw_log_warn("%p: unknown peer %p fd:%d", impl, peer,
 			peer->source.fd);
 		return;
 	}
-
-	pw_log_debug("%p: peer %p/%p id:%u removed mem_id:%u", impl, peer,
-			impl->this.node, peer->info.id, m->id);
+	pw_log_debug("%p: peer %p %u removed", impl, peer,
+			peer->info.id);
 
 	if (impl->resource != NULL) {
 		pw_client_node_resource_set_activation(impl->resource,
@@ -1244,6 +1244,7 @@ static void node_peer_removed(void *data, struct pw_impl_node *peer)
 					  0,
 					  0);
 	}
+
 	pw_memblock_unref(m);
 }
 
@@ -1350,7 +1351,7 @@ static void node_free(void *data)
 		pw_resource_destroy(impl->resource);
 
 	if (impl->activation)
-		pw_memblock_free(impl->activation);
+		pw_memblock_unref(impl->activation);
 
 	pw_array_for_each(area, &impl->io_areas) {
 		if (*area)
diff --git a/src/modules/module-client-node/remote-node.c b/src/modules/module-client-node/remote-node.c
index a4fe878e2a..365c109a02 100644
--- a/src/modules/module-client-node/remote-node.c
+++ b/src/modules/module-client-node/remote-node.c
@@ -47,8 +47,6 @@ struct mix {
 
 struct node_data {
 	struct pw_context *context;
-	struct spa_hook context_listener;
-
 	struct pw_loop *data_loop;
 	struct spa_system *data_system;
 
@@ -1119,9 +1117,6 @@ static void client_node_removed(void *_data)
 	spa_hook_remove(&data->proxy_client_node_listener);
 	spa_hook_remove(&data->client_node_listener);
 
-	pw_context_driver_remove_listener(data->context,
-			&data->context_listener);
-
 	if (data->node) {
 		spa_hook_remove(&data->node_listener);
 		pw_impl_node_set_state(data->node, PW_NODE_STATE_SUSPENDED);
@@ -1158,22 +1153,67 @@ static const struct pw_proxy_events proxy_client_node_events = {
 	.bound_props = client_node_bound_props,
 };
 
-static void context_complete(void *data, struct pw_impl_node *node)
+static inline uint64_t get_time_ns(struct spa_system *system)
 {
-	struct node_data *d = data;
-	struct spa_system *data_system = d->data_system;
+	struct timespec ts;
+	spa_system_clock_gettime(system, CLOCK_MONOTONIC, &ts);
+	return SPA_TIMESPEC_TO_NSEC(&ts);
+}
 
-	if (node != d->node || !node->driving ||
-	    !SPA_FLAG_IS_SET(node->rt.target.activation->flags, PW_NODE_ACTIVATION_FLAG_PROFILER))
-		return;
+static int node_ready(void *d, int status)
+{
+	struct node_data *data = d;
+	struct pw_impl_node *node = data->node;
+	struct pw_node_activation *a = node->rt.target.activation;
+	struct spa_system *data_system = data->data_system;
+	struct pw_impl_port *p;
 
-	if (SPA_UNLIKELY(spa_system_eventfd_write(data_system, d->rtwritefd, 1) < 0))
+	pw_log_trace_fp("node %p: ready driver:%d exported:%d status:%d", node,
+			node->driver, node->exported, status);
+
+	if (status & SPA_STATUS_HAVE_DATA) {
+		spa_list_for_each(p, &node->rt.output_mix, rt.node_link)
+			spa_node_process_fast(p->mix);
+	}
+
+	a->state[0].status = status;
+	a->signal_time = get_time_ns(data_system);
+
+	if (SPA_UNLIKELY(spa_system_eventfd_write(data_system, data->rtwritefd, 1) < 0))
 		pw_log_warn("node %p: write failed %m", node);
+
+	return 0;
 }
 
-static const struct pw_context_driver_events context_events = {
-	PW_VERSION_CONTEXT_DRIVER_EVENTS,
-	.complete = context_complete,
+static int node_reuse_buffer(void *data, uint32_t port_id, uint32_t buffer_id)
+{
+	return 0;
+}
+
+static int node_xrun(void *d, uint64_t trigger, uint64_t delay, struct spa_pod *info)
+{
+	struct node_data *data = d;
+	struct pw_impl_node *node = data->node;
+	struct pw_node_activation *a = node->rt.target.activation;
+
+	a->xrun_count++;
+	a->xrun_time = trigger;
+	a->xrun_delay = delay;
+	a->max_delay = SPA_MAX(a->max_delay, delay);
+
+	pw_log_debug("node %p: XRun! count:%u time:%"PRIu64" delay:%"PRIu64" max:%"PRIu64,
+			node, a->xrun_count, trigger, delay, a->max_delay);
+
+	pw_context_driver_emit_xrun(data->context, node);
+
+	return 0;
+}
+
+static const struct spa_node_callbacks node_callbacks = {
+	SPA_VERSION_NODE_CALLBACKS,
+	.ready = node_ready,
+	.reuse_buffer = node_reuse_buffer,
+	.xrun = node_xrun
 };
 
 static struct pw_proxy *node_export(struct pw_core *core, void *object, bool do_free,
@@ -1224,16 +1264,13 @@ static struct pw_proxy *node_export(struct pw_core *core, void *object, bool do_
 			&data->proxy_client_node_listener,
 			&proxy_client_node_events, data);
 
+	spa_node_set_callbacks(node->node, &node_callbacks, data);
 	pw_impl_node_add_listener(node, &data->node_listener, &node_events, data);
 
 	pw_client_node_add_listener(data->client_node,
 					  &data->client_node_listener,
 					  &client_node_events,
 					  data);
-	pw_context_driver_add_listener(data->context,
-			&data->context_listener,
-			&context_events, data);
-
 	do_node_init(data);
 
 	return client_node;
diff --git a/src/pipewire/extensions/client-node.h b/src/pipewire/extensions/client-node.h
index abcd6b6993..7536c58dd2 100644
--- a/src/pipewire/extensions/client-node.h
+++ b/src/pipewire/extensions/client-node.h
@@ -22,7 +22,7 @@ extern "C" {
  */
 #define PW_TYPE_INTERFACE_ClientNode		PW_TYPE_INFO_INTERFACE_BASE "ClientNode"
 
-#define PW_VERSION_CLIENT_NODE			5
+#define PW_VERSION_CLIENT_NODE			4
 struct pw_client_node;
 
 #define PW_EXTENSION_MODULE_CLIENT_NODE		PIPEWIRE_MODULE_PREFIX "module-client-node"
diff --git a/src/pipewire/impl-node.c b/src/pipewire/impl-node.c
index d7b8f330b6..586c9782b6 100644
--- a/src/pipewire/impl-node.c
+++ b/src/pipewire/impl-node.c
@@ -41,6 +41,8 @@ struct impl {
 
 	unsigned int cache_params:1;
 	unsigned int pending_play:1;
+
+	uint64_t prev_signal_time;
 };
 
 #define pw_node_resource(r,m,v,...)	pw_resource_call(r,struct pw_node_events,m,v,__VA_ARGS__)
@@ -901,8 +903,8 @@ int pw_impl_node_set_driver(struct pw_impl_node *node, struct pw_impl_node *driv
 
 	pw_impl_node_emit_driver_changed(node, old, driver);
 
-	pw_impl_node_emit_peer_added(driver, node);
 	pw_impl_node_emit_peer_removed(old, node);
+	pw_impl_node_emit_peer_added(driver, node);
 
 	return 0;
 }
@@ -1247,7 +1249,6 @@ static inline int process_node(void *data)
 		/* calculate CPU time when finished */
 		a->signal_time = this->driver_start;
 		calculate_stats(this, a);
-		pw_context_driver_emit_complete(this->context, this);
 	}
 
 	if (SPA_UNLIKELY(status & SPA_STATUS_DRAINED))
@@ -1739,7 +1740,8 @@ static inline void update_position(struct pw_impl_node *node, int all_ready, uin
  */
 static int node_ready(void *data, int status)
 {
-	struct pw_impl_node *node = data;
+	struct pw_impl_node *node = data, *reposition_node = NULL;
+	struct impl *impl = SPA_CONTAINER_OF(node, struct impl, this);
 	struct pw_impl_node *driver = node->driver_node;
 	struct pw_node_activation *a = node->rt.target.activation;
 	struct spa_system *data_system = node->data_system;
@@ -1774,6 +1776,18 @@ static int node_ready(void *data, int status)
 					state->pending, state->required);
 			check_states(node, nsec);
 			pw_context_driver_emit_incomplete(node->context, node);
+		} else {
+			uint64_t signal_time = a->signal_time;
+			/* old nodes set the TRIGGERED status on node_ready, patch this
+			 * up here to avoid errors in pw-top */
+			a->status = PW_NODE_ACTIVATION_FINISHED;
+			a->signal_time = a->prev_signal_time;
+			a->prev_signal_time = impl->prev_signal_time;
+
+			pw_context_driver_emit_complete(node->context, node);
+
+			a->prev_signal_time = a->signal_time;
+			a->signal_time = signal_time;
 		}
 
 		/* This update is done too late, the driver should do this
@@ -1823,9 +1837,13 @@ again:
 		}
 
 		a->status = PW_NODE_ACTIVATION_TRIGGERED;
+		/* remote nodes set the signal_time before writing the ready
+		 * eventfd */
+		if (!node->remote)
+			a->signal_time = nsec;
+		impl->prev_signal_time = a->prev_signal_time;
 		a->prev_signal_time = a->signal_time;
 		a->signal_time = nsec;
-		node->driver_start = nsec;
 
 		a->sync_timeout = SPA_MIN(min_timeout, DEFAULT_SYNC_TIMEOUT);
 
@@ -1852,7 +1870,9 @@ again:
 		a->status = PW_NODE_ACTIVATION_FINISHED;
 		a->finish_time = nsec;
 	}
-	if (status & SPA_STATUS_HAVE_DATA) {
+	if (!node->remote && (status & SPA_STATUS_HAVE_DATA)) {
+		/* remote nodes have done the output mix already before
+		 * they wrote the ready eventfd */
 		spa_list_for_each(p, &node->rt.output_mix, rt.node_link)
 			spa_node_process_fast(p->mix);
 	}
-- 
GitLab

